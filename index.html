<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RIDER AR + INTERPRETATION</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/ort.min.js"></script>
    <style>
        /* ОСНОВА */
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        #app { position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column; }
        
        video { display: none; } /* Скрыто, рисуем на канвасе */
        canvas { display: block; width: 100%; height: 100%; object-fit: cover; }

        /* UI СЛОЙ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        /* КНОПКА СКАНЕРА (Только в режиме камеры) */
        #scan-btn {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 70px; height: 70px; border-radius: 50%;
            background: rgba(0, 0, 0, 0.3); border: 4px solid #ffd700;
            cursor: pointer; pointer-events: auto;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
            transition: transform 0.2s, opacity 0.3s;
        }
        #scan-btn:active { transform: translateX(-50%) scale(0.9); background: #ffd700; }
        #scan-btn.hidden { opacity: 0; pointer-events: none; transform: translateX(-50%) translateY(50px); }

        /* ЧЕРНАЯ ПОЛОСА ТОЛКОВАНИЯ (Выезжает снизу) */
        #interpretation-panel {
            position: absolute; bottom: 0; left: 0; width: 100%;
            height: 40vh; /* Высота панели */
            background: #080808; /* Почти черный */
            border-top: 2px solid #ffd700;
            border-radius: 20px 20px 0 0;
            box-shadow: 0 -5px 30px rgba(0,0,0,0.8);
            transform: translateY(110%); /* Спрятано внизу */
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
            pointer-events: auto;
            display: flex; flex-direction: column;
            z-index: 20;
        }
        #interpretation-panel.visible { transform: translateY(0); }

        /* ВНУТРЕННОСТИ ПАНЕЛИ */
        .panel-header {
            padding: 15px 20px;
            border-bottom: 1px solid #333;
            display: flex; justify-content: space-between; align-items: center;
        }
        .panel-title { color: #ffd700; font-size: 14px; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }
        
        .btn-reset {
            background: transparent; border: 1px solid #ffd700; color: #ffd700;
            padding: 5px 12px; border-radius: 15px; font-size: 11px; cursor: pointer;
        }

        .panel-content {
            flex: 1; padding: 20px; overflow-y: auto; color: #ccc; font-size: 14px; line-height: 1.6;
        }
        
        .card-item { margin-bottom: 15px; }
        .card-name { color: #fff; font-weight: bold; font-size: 16px; margin-bottom: 4px; display: flex; align-items: center; }
        .card-score { font-size: 10px; color: #666; margin-left: 8px; border: 1px solid #444; padding: 1px 4px; border-radius: 4px; }
        .card-desc { font-size: 13px; color: #999; }

        /* Лоадер */
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ffd700; background: rgba(0,0,0,0.8); padding: 10px 20px; border-radius: 8px;
            display: none; font-size: 12px;
        }
    </style>
</head>
<body>

<div id="app">
    <video id="video" playsinline muted autoplay></video>
    <canvas id="canvas"></canvas>

    <div id="ui-layer">
        <div id="loader">Загрузка нейросети...</div>
        
        <div id="scan-btn" onclick="scan()"></div>

        <div id="interpretation-panel">
            <div class="panel-header">
                <div class="panel-title">РЕЗУЛЬТАТ</div>
                <button class="btn-reset" onclick="reset()">НОВЫЙ СКАН</button>
            </div>
            <div class="panel-content" id="panel-text">
                </div>
        </div>
    </div>
</div>

<script>
    // === 1. НАСТРОЙКИ ===
    const CONFIG = {
        model: './rider_gold_800.onnx',
        size: 800,
        conf: 0.25,
        iou: 0.45
    };

    // ИМЕНА КАРТ (0-77)
    const CLASS_NAMES = [
        "Шут", "Маг", "Жрица", "Императрица", "Император", "Жрец", "Влюбленные", "Колесница",
        "Сила", "Отшельник", "Колесо Фортуны", "Справедливость", "Повешенный", "Смерть",
        "Умеренность", "Дьявол", "Башня", "Звезда", "Луна", "Солнце", "Суд", "Мир",
        "Туз Жезлов", "2 Жезлов", "3 Жезлов", "4 Жезлов", "5 Жезлов", "6 Жезлов", "7 Жезлов", "8 Жезлов", "9 Жезлов", "10 Жезлов", "Паж Жезлов", "Рыцарь Жезлов", "Королева Жезлов", "Король Жезлов",
        "Туз Кубков", "2 Кубков", "3 Кубков", "4 Кубков", "5 Кубков", "6 Кубков", "7 Кубков", "8 Кубков", "9 Кубков", "10 Кубков", "Паж Кубков", "Рыцарь Кубков", "Королева Кубков", "Король Кубков",
        "Туз Мечей", "2 Мечей", "3 Мечей", "4 Мечей", "5 Мечей", "6 Мечей", "7 Мечей", "8 Мечей", "9 Мечей", "10 Мечей", "Паж Мечей", "Рыцарь Мечей", "Королева Мечей", "Король Мечей",
        "Туз Пентаклей", "2 Пентаклей", "3 Пентаклей", "4 Пентаклей", "5 Пентаклей", "6 Пентаклей", "7 Пентаклей", "8 Пентаклей", "9 Пентаклей", "10 Пентаклей", "Паж Пентаклей", "Рыцарь Пентаклей", "Королева Пентаклей", "Король Пентаклей"
    ];

    let session;
    let isFrozen = false;
    
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const loader = document.getElementById('loader');
    const scanBtn = document.getElementById('scan-btn');
    const panel = document.getElementById('interpretation-panel');
    const panelText = document.getElementById('panel-text');

    // Канвас для тензора
    const tensorCanvas = document.createElement('canvas');
    tensorCanvas.width = CONFIG.size; tensorCanvas.height = CONFIG.size;
    const tensorCtx = tensorCanvas.getContext('2d', {willReadFrequently: true});

    // === ИНИЦИАЛИЗАЦИЯ ===
    async function init() {
        loader.style.display = 'block';
        try {
            ort.env.wasm.wasmPaths = "https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/";
            session = await ort.InferenceSession.create(CONFIG.model, { executionProviders: ['wasm'] });
            
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } } 
            });
            video.srcObject = stream;
            video.onloadedmetadata = () => {
                video.play();
                resize();
                loader.style.display = 'none';
                requestAnimationFrame(loop);
            };
        } catch(e) {
            loader.innerText = "Ошибка: " + e.message;
        }
    }
    window.onload = init;
    window.addEventListener('resize', resize);
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }

    // === ЦИКЛ ВИДЕО ===
    function loop() {
        if (!isFrozen) {
            drawVideo(false); // Рисуем видео
            drawCrosshair();  // Рисуем прицел
            requestAnimationFrame(loop);
        }
    }

    function drawVideo(returnParams = false) {
        const vW = video.videoWidth, vH = video.videoHeight;
        const cW = canvas.width, cH = canvas.height;
        const scale = Math.max(cW / vW, cH / vH); // Object-cover
        const x = (cW - vW * scale) / 2;
        const y = (cH - vH * scale) / 2;
        
        ctx.drawImage(video, x, y, vW * scale, vH * scale);
        
        if(returnParams) return { x, y, scale };
    }

    function drawCrosshair() {
        const size = Math.min(canvas.width, canvas.height) * 0.6;
        const cx = canvas.width/2, cy = canvas.height/2;
        ctx.strokeStyle = "rgba(255,255,255,0.2)";
        ctx.lineWidth = 1;
        ctx.strokeRect(cx-size/2, cy-size/2, size, size);
    }

    // === СКАН ===
    async function scan() {
        if(isFrozen) return;
        
        // 1. UI: Прячем кнопку, морозим экран
        isFrozen = true;
        scanBtn.classList.add('hidden');
        loader.innerText = "Анализ расклада...";
        loader.style.display = 'block';

        // 2. Снимок экрана
        const screenParams = drawVideo(true); 

        // 3. Подготовка 800x800
        const vW = video.videoWidth, vH = video.videoHeight;
        const scaleT = Math.min(CONFIG.size/vW, CONFIG.size/vH);
        const tx = (CONFIG.size - vW*scaleT)/2;
        const ty = (CONFIG.size - vH*scaleT)/2;
        
        tensorCtx.fillStyle="#000"; tensorCtx.fillRect(0,0,CONFIG.size,CONFIG.size);
        tensorCtx.drawImage(video, tx, ty, vW*scaleT, vH*scaleT);
        
        const imgData = tensorCtx.getImageData(0,0,CONFIG.size,CONFIG.size).data;
        const float32 = new Float32Array(3*CONFIG.size*CONFIG.size);
        for(let i=0; i<CONFIG.size**2; i++) {
            float32[i] = imgData[i*4]/255.0; 
            float32[CONFIG.size**2+i] = imgData[i*4+1]/255.0; 
            float32[2*CONFIG.size**2+i] = imgData[i*4+2]/255.0;
        }
        const tensor = new ort.Tensor('float32', float32, [1, 3, CONFIG.size, CONFIG.size]);

        // 4. Инференс
        try {
            const res = await session.run({[session.inputNames[0]]: tensor});
            const output = res[session.outputNames[0]];
            const boxes = nms(parseYOLOv8(output)); // Парсинг + NMS
            
            loader.style.display = 'none';
            
            // 5. Отрисовка результатов + Заполнение панели
            drawAR(boxes, tx, ty, scaleT, screenParams);
            showPanel(boxes);

        } catch(e) {
            console.error(e);
            loader.innerText = "Ошибка!";
            setTimeout(reset, 2000);
        }
    }

    // === ОТРИСОВКА AR ===
    function drawAR(boxes, tx, ty, tScale, sParams) {
        // Затемняем фон, чтобы рамки сияли
        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.fillRect(0,0,canvas.width, canvas.height);

        boxes.forEach((b, idx) => {
            // Конвертация координат
            const vx = (b.x - tx) / tScale;
            const vy = (b.y - ty) / tScale;
            const vw = b.w / tScale;
            const vh = b.h / tScale;
            
            const sx = sParams.x + vx * sParams.scale;
            const sy = sParams.y + vy * sParams.scale;
            const sw = vw * sParams.scale;
            const sh = vh * sParams.scale;

            // Рамка
            ctx.shadowColor = "#ffd700";
            ctx.shadowBlur = 15;
            ctx.strokeStyle = "#ffd700";
            ctx.lineWidth = 3;
            ctx.strokeRect(sx - sw/2, sy - sh/2, sw, sh);
            ctx.shadowBlur = 0; // сброс

            // Номер карты
            ctx.fillStyle = "#ffd700";
            ctx.beginPath();
            ctx.arc(sx - sw/2, sy - sh/2, 12, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = "#000";
            ctx.font = "bold 12px sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(idx+1, sx - sw/2, sy - sh/2);
        });
    }

    // === ЗАПОЛНЕНИЕ ПАНЕЛИ ===
    function showPanel(boxes) {
        // Сортируем карты: Слева направо, сверху вниз
        boxes.sort((a,b) => (a.y - b.y) || (a.x - b.x));

        let html = '';
        if(boxes.length === 0) {
            html = '<div style="text-align:center; padding-top:20px;">Карты не найдены.<br>Попробуйте ближе или включите свет.</div>';
        } else {
            boxes.forEach((b, idx) => {
                const name = CLASS_NAMES[b.cls] || `Карта #${b.cls}`;
                const score = Math.round(b.score*100);
                
                html += `
                <div class="card-item">
                    <div class="card-name">
                        ${idx+1}. ${name} 
                        <span class="card-score">${score}%</span>
                    </div>
                    <div class="card-desc">
                        Здесь будет краткое толкование карты в контексте расклада...
                    </div>
                </div>`;
            });
        }
        
        panelText.innerHTML = html;
        panel.classList.add('visible');
    }

    // === СБРОС ===
    function reset() {
        isFrozen = false;
        panel.classList.remove('visible');
        scanBtn.classList.remove('hidden');
        requestAnimationFrame(loop);
    }

    // === ЛОГИКА YOLO ===
    function parseYOLOv8(output) {
        const dims = output.dims; // [1, 82, 13125]
        const data = output.data;
        const numAnchors = dims[2];
        const numClasses = dims[1] - 4;
        const boxes = [];
        
        for (let i = 0; i < numAnchors; i++) {
            let maxScore = 0;
            let cls = -1;
            for (let c = 0; c < numClasses; c++) {
                const val = data[(c+4)*numAnchors + i];
                if (val > maxScore) { maxScore = val; cls = c; }
            }
            if (maxScore > CONFIG.conf) {
                boxes.push({
                    x: data[0*numAnchors+i],
                    y: data[1*numAnchors+i],
                    w: data[2*numAnchors+i],
                    h: data[3*numAnchors+i],
                    score: maxScore, cls: cls
                });
            }
        }
        return boxes;
    }

    function nms(boxes) {
        if (!boxes.length) return [];
        boxes.sort((a,b) => b.score - a.score);
        const res = [];
        while(boxes.length) {
            const best = boxes.shift();
            res.push(best);
            boxes = boxes.filter(b => {
                const x1 = Math.max(best.x-best.w/2, b.x-b.w/2);
                const y1 = Math.max(best.y-best.h/2, b.y-b.h/2);
                const x2 = Math.min(best.x+best.w/2, b.x+b.w/2);
                const y2 = Math.min(best.y+best.h/2, b.y+b.h/2);
                const inter = Math.max(0, x2-x1) * Math.max(0, y2-y1);
                const union = (best.w*best.h) + (b.w*b.h) - inter;
                return (inter/union) < CONFIG.iou;
            });
        }
        return res;
    }
</script>
</body>
</html>
