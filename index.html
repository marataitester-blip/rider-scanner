<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AURA: TILING SCANNER</title>
    
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/ort.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Roboto', sans-serif; }
        
        /* ВИДЕОИСКАТЕЛЬ */
        #viewfinder { position: relative; width: 100vw; height: 100vh; }
        video { width: 100%; height: 100%; object-fit: cover; }
        
        /* Сетка прицела (для удобства) */
        .grid-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;
            background: 
                linear-gradient(rgba(212,175,55,0.3) 1px, transparent 1px),
                linear-gradient(90deg, rgba(212,175,55,0.3) 1px, transparent 1px);
            background-size: 33% 33%;
            opacity: 0.5;
        }

        /* ИНТЕРФЕЙС */
        #ui-layer { 
            position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;
            display: flex; flex-direction: column; justify-content: space-between; z-index: 20;
        }
        .header { 
            padding: 20px; text-align: center; color: #d4af37; font-size: 18px; font-weight: bold; 
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }
        .footer { 
            padding: 40px; display: flex; justify-content: center; pointer-events: auto;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
        }

        /* КНОПКА ЗАТВОРА */
        #shutter-btn {
            width: 80px; height: 80px; border-radius: 50%; border: 4px solid #d4af37;
            background: rgba(212, 175, 55, 0.2); cursor: pointer; position: relative;
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.4); transition: 0.1s;
        }
        #shutter-btn:active { transform: scale(0.95); background: #d4af37; }

        /* ИНДИКАТОР ЗАГРУЗКИ */
        #loader-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.9);
            z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .spinner { width:50px; height:50px; border:5px solid #333; border-top:5px solid #d4af37; border-radius:50%; animation: spin 1s infinite; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        #proc-status { margin-top: 20px; color: #d4af37; font-size: 14px; }

        /* ЭКРАН РЕЗУЛЬТАТА */
        #result-screen {
            position: absolute; top:0; left:0; width:100%; height:100%; background:#111; z-index:50;
            display: none; flex-direction: column;
        }
        #visual-layout {
            flex: 1; background: #050505; position: relative; margin: 10px; 
            border: 1px solid #d4af37; border-radius: 8px; overflow: hidden;
        }
        .res-controls {
            height: 80px; display: flex; justify-content: center; align-items: center; 
            border-top: 1px solid #333; background: #1a1a1a;
        }
        #retry-btn {
            padding: 10px 30px; border: 1px solid #d4af37; color: #d4af37; background: transparent;
            font-size: 16px; border-radius: 20px; cursor: pointer;
        }

        /* Карточка на столе */
        .layout-card {
            position: absolute; border: 1px solid #d4af37; border-radius: 4px; 
            box-shadow: 0 4px 10px rgba(0,0,0,0.8);
        }
        .layout-card img { width: 100%; height: 100%; object-fit: cover; }
        .layout-card span {
            position: absolute; bottom: -20px; width: 150%; left: -25%; text-align: center;
            color: #d4af37; font-size: 10px; text-shadow: 0 1px 2px #000;
        }
    </style>
</head>
<body>

<div id="loader-overlay">
    <div class="spinner"></div>
    <div id="proc-status">Загрузка системы...</div>
    <button id="init-btn" onclick="startCamera()" style="margin-top:20px; display:none; padding:10px 20px; background:#d4af37; border:none; border-radius:5px;">НАЧАТЬ</button>
</div>

<div id="viewfinder">
    <video id="video" playsinline muted autoplay></video>
    <div class="grid-overlay"></div>
</div>

<div id="ui-layer">
    <div class="header">AURA TILING SCANNER</div>
    <div class="footer">
        <div id="shutter-btn" onclick="captureAndProcess()"></div>
    </div>
</div>

<div id="result-screen">
    <div id="visual-layout"></div>
    <div class="res-controls">
        <button id="retry-btn" onclick="reset()">НОВЫЙ СКАН</button>
    </div>
</div>

<script>
    // === БАЗА КАРТ AURA ===
    const BASE_URL = "https://cdn.jsdelivr.net/gh/marataitester-blip/tarot/";
    const CARDS = [];
    
    // Генерация имен (должна совпадать с обучением)
    const MAJORS = [
        "00_fool", "01_magician", "02_high_priestess", "03_empress", "04_emperor", "05_hierophant",
        "06_lovers", "07_chariot", "08_justice", "09_hermit", "10_wheel_of_fortune", "11_strength",
        "12_hanged_man", "13_death", "14_temperance", "15_devil", "16_tower", "17_star",
        "18_moon", "19_sun", "20_judgement", "21_world", "22_hero", "23_white_card"
    ];
    MAJORS.forEach(m => CARDS.push({name: m.split('_').slice(1).join(' ').toUpperCase(), img: BASE_URL+m+".png"}));
    
    const SUITS = ["wands", "cups", "swords", "pentacles"];
    const RANKS = ["01_ace", "02_two", "03_three", "04_four", "05_five", "06_six", "07_seven", "08_eight", "09_nine", "10_ten", "11_page", "12_knight", "13_queen", "14_king"];
    SUITS.forEach(s => RANKS.forEach(r => {
        let n = r.split('_')[1] + " of " + s;
        CARDS.push({name: n.toUpperCase(), img: BASE_URL+s+"_"+r+".png"});
    }));

    // === НАСТРОЙКИ ===
    const MODEL_PATH = './aura_gold_800.onnx';
    const MODEL_SIZE = 800; // Размер входа модели
    const CONF_THRESH = 0.30;
    const IOU_THRESH = 0.40;
    
    let session = null;
    const video = document.getElementById('video');

    // === 1. СТАРТ ===
    window.onload = async () => {
        try {
            document.getElementById('proc-status').innerText = "Загрузка нейросети (800px)...";
            session = await ort.InferenceSession.create(MODEL_PATH, { executionProviders: ['wasm'] });
            document.getElementById('loader-overlay').style.display = 'none';
            startCamera();
        } catch (e) {
            document.getElementById('proc-status').innerText = "Ошибка: " + e.message;
            document.getElementById('init-btn').style.display = 'block';
        }
    };

    async function startCamera() {
        try {
            // Просим 4K, если нет - даст максимум что есть
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment', width: { ideal: 3840 }, height: { ideal: 2160 } }
            });
            video.srcObject = stream;
        } catch (e) { alert("Камера недоступна"); }
    }

    // === 2. ЗАХВАТ И НАРЕЗКА (TILING) ===
    async function captureAndProcess() {
        // Интерфейс
        document.getElementById('loader-overlay').style.display = 'flex';
        document.getElementById('proc-status').innerText = "Захват высокого разрешения...";
        
        // 1. Делаем снимок полного разрешения в Canvas
        const fullCanvas = document.createElement('canvas');
        fullCanvas.width = video.videoWidth;
        fullCanvas.height = video.videoHeight;
        const fullCtx = fullCanvas.getContext('2d');
        fullCtx.drawImage(video, 0, 0);

        // 2. Генерируем тайлы (800x800 с перекрытием)
        const tiles = generateTiles(fullCanvas.width, fullCanvas.height, MODEL_SIZE, 0.2); // 20% перекрытие
        let allDetections = [];

        // 3. Прогоняем каждый тайл
        for (let i = 0; i < tiles.length; i++) {
            document.getElementById('proc-status').innerText = `Анализ сектора ${i+1}/${tiles.length}...`;
            // Даем браузеру отрисовать текст
            await new Promise(r => setTimeout(r, 10));

            const t = tiles[i];
            const detections = await runInferenceOnTile(fullCtx, t.x, t.y, MODEL_SIZE);
            
            // Конвертируем локальные координаты тайла в глобальные
            detections.forEach(d => {
                allDetections.push({
                    x: t.x + d.x, // Глобальный X
                    y: t.y + d.y, // Глобальный Y
                    w: d.w,
                    h: d.h,
                    score: d.score,
                    cls: d.cls
                });
            });
        }

        // 4. Фильтруем дубликаты (NMS)
        document.getElementById('proc-status').innerText = "Склейка результатов...";
        const finalBoxes = applyGlobalNMS(allDetections);

        showResult(finalBoxes, fullCanvas.width, fullCanvas.height);
        document.getElementById('loader-overlay').style.display = 'none';
    }

    // Генератор координат тайлов
    function generateTiles(imgW, imgH, tileSize, overlap) {
        const step = Math.floor(tileSize * (1 - overlap));
        const tiles = [];
        
        // Добавляем глобальный обзор (ресайз всего фото до 800px) - чтобы видеть крупные карты
        // Но для 80 карт лучше работать чисто по тайлам. Оставим пока простую сетку.
        
        for (let y = 0; y < imgH; y += step) {
            for (let x = 0; x < imgW; x += step) {
                // Корректировка, чтобы не вылезти за край
                let safeX = x;
                let safeY = y;
                if (safeX + tileSize > imgW) safeX = Math.max(0, imgW - tileSize);
                if (safeY + tileSize > imgH) safeY = Math.max(0, imgH - tileSize);
                
                tiles.push({x: safeX, y: safeY});
            }
        }
        // Удаляем полные дубликаты, если картинка меньше шага
        return tiles.filter((t, index, self) => 
            index === self.findIndex((tt) => (tt.x === t.x && tt.y === t.y))
        );
    }

    // === 3. ИНФЕРЕНС (YOLO) ===
    async function runInferenceOnTile(ctx, x, y, size) {
        // Вырезаем кусок
        const tileData = ctx.getImageData(x, y, size, size);
        const input = new Float32Array(3 * size * size);
        
        // Нормализация 0..1
        for (let i = 0; i < size * size; i++) {
            input[i] = tileData.data[i*4] / 255.0;
            input[size*size + i] = tileData.data[i*4+1] / 255.0;
            input[2*size*size + i] = tileData.data[i*4+2] / 255.0;
        }

        const tensor = new ort.Tensor('float32', input, [1, 3, size, size]);
        const res = await session.run({ [session.inputNames[0]]: tensor });
        const output = res[session.outputNames[0]].data;

        // Парсинг (80 классов)
        const numClasses = 80; 
        const channels = numClasses + 4;
        const anchors = output.length / channels;
        const boxes = [];

        for (let i = 0; i < anchors; i++) {
            let max = 0, cls = 0;
            for (let c = 4; c < channels; c++) {
                const val = output[c*anchors + i];
                if (val > max) { max = val; cls = c - 4; }
            }
            if (max > CONF_THRESH) {
                // Координаты внутри тайла (в пикселях)
                const bx = output[0*anchors + i];
                const by = output[1*anchors + i];
                const bw = output[2*anchors + i];
                const bh = output[3*anchors + i];
                boxes.push({ x: bx, y: by, w: bw, h: bh, score: max, cls: cls });
            }
        }
        return boxes;
    }

    // === 4. ГЛОБАЛЬНЫЙ NMS ===
    function applyGlobalNMS(boxes) {
        boxes.sort((a, b) => b.score - a.score);
        const result = [];
        
        while (boxes.length > 0) {
            const best = boxes.shift();
            result.push(best);
            
            boxes = boxes.filter(b => {
                // Считаем IoU
                const x1 = Math.max(best.x - best.w/2, b.x - b.w/2);
                const y1 = Math.max(best.y - best.h/2, b.y - b.h/2);
                const x2 = Math.min(best.x + best.w/2, b.x + b.w/2);
                const y2 = Math.min(best.y + best.h/2, b.y + b.h/2);
                
                if (x2 < x1 || y2 < y1) return true; // Не пересекаются -> оставляем
                
                const inter = (x2 - x1) * (y2 - y1);
                const union = (best.w * best.h) + (b.w * b.h) - inter;
                return (inter / union) < IOU_THRESH; // Если пересечение маленькое -> оставляем
            });
        }
        return result;
    }

    // === 5. ВИЗУАЛИЗАЦИЯ ===
    function showResult(boxes, imgW, imgH) {
        const container = document.getElementById('visual-layout');
        container.innerHTML = "";
        
        if(boxes.length === 0) {
            container.innerHTML = '<div style="position:absolute;top:50%;width:100%;text-align:center;color:#666">Карты не найдены</div>';
        }

        // Вычисляем масштаб для отображения
        let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
        boxes.forEach(b => {
            minX = Math.min(minX, b.x); maxX = Math.max(maxX, b.x);
            minY = Math.min(minY, b.y); maxY = Math.max(maxY, b.y);
        });

        // Центрируем расклад в окне
        const layoutW = (maxX - minX) * 1.5 || imgW;
        const layoutH = (maxY - minY) * 1.5 || imgH;
        const cX = (minX + maxX) / 2;
        const cY = (minY + maxY) / 2;

        boxes.forEach(b => {
            const card = CARDS[b.cls];
            if (!card) return;

            const el = document.createElement('div');
            el.className = 'layout-card';
            
            // Конвертируем в % относительно контейнера
            const left = 50 + ((b.x - cX) / layoutW) * 80;
            const top = 50 + ((b.y - cY) / layoutH) * 80;
            const w = (b.w / layoutW) * 80;
            
            el.style.left = left + "%";
            el.style.top = top + "%";
            el.style.width = w + "%";
            el.style.height = (w * 1.7) + "%";
            el.style.transform = "translate(-50%, -50%)";

            el.innerHTML = `<img src="${card.img}"><span>${card.name}</span>`;
            container.appendChild(el);
        });

        document.getElementById('ui-layer').style.display = 'none';
        document.getElementById('result-screen').style.display = 'flex';
    }

    function reset() {
        document.getElementById('result-screen').style.display = 'none';
        document.getElementById('ui-layer').style.display = 'flex';
        video.play();
    }
</script>
</body>
</html>
